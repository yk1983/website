<!DOCTYPE html>
<!--[if IE 8]> <html lang="ko" class="ie8"> <![endif]-->
<!--[if IE 9]> <html lang="ko" class="ie9"> <![endif]-->
<!--[if !IE]><!-->
<html lang="ko">
<!--<![endif]-->

<head>
	<title>KINCOWEB STD</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<!-- Latest compiled and minified CSS -->
	<!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"> -->
	<script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
	<!--[if lte IE 8]><script src="/website/assets/js/ie/html5shiv.js"></script><![endif]-->
	<link rel="stylesheet" href="/website/assets/css/main.css" />
	<!--[if lte IE 9]><link rel="stylesheet" href="/website/assets/css/ie9.css" /><![endif]-->
	<!--[if lte IE 8]><link rel="stylesheet" href="/website/assets/css/ie8.css" /><![endif]-->
</head>

<body>

	<!-- Header -->
	<header id="header">
		<a href="/website/index.html" class="title">KINCOWEB STD</a>
		<nav>
			<ul>
				<li>
					<a href="/website/java/index.html">Java</a>
				</li>
				<li>
					<a href="Generics.html">Annotation</a>
				</li>
				<li>
					<a class="active">애너테이션</a>
				</li>
			</ul>
		</nav>
	</header>

	<!-- Wrapper -->
	<div id="wrapper">

		<!-- Main -->
		<section id="main" class="wrapper">
			<div class="inner">
				<h1 class="major">애너테이션 (Annotation)</h1>
				<p>
					애너테이션(Annotation)은 주석, 주해, 메모란 뜻으로, 자바 개발자들은 소스코드에 대한 문서를 따로 만들기 보다 소스코드와 문서를 하나의 파일로 관리하는 것이 좋다고 생각하여 소스코드의 주석
					<code>/** ~ */</code>에 소스코드에 대한 정보를 저장하고, 소스코드의 주석으로부터 HTML문서를 생성해내는 프로그램(
					<code>javadoc.exe</code>)을 만들어 사용했습니다.
					<br/>/**로 시작하는 주석 안에 소스코드에 대한 설명들이 있고, 그 안에 @이 붙은 태그들이 있습니다. 미리 정의된 태그들을 이용해서 주석 안에 정보를 저장하고,
					<code>javadoc.exe</code>라는 프로그램이 이 정보를 읽어서 문서를 작성하는데 사용합니다.
					<br/>이러한 기능을 응용하여
					<strong>프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것</strong>이 애너테이션입니다. 애너테이션은 주석(comment)처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른
					프로그램에게 유용한 정보를 제공할 수 있다는 장점이 있습니다.
				</p>

				<hr>

				<section>
					<h2>표준 애너테이션</h2>
					<p>

					</p>

					<h4>표준 애너테이션(*메타 애너테이션)</h4>
					<table>
						<tbody>
							<tr>
								<td>
									<strong>
										<em>@Override</em>
									</strong>
									<br/> : 컴파일러에게 오버라이딩하는 메서드임을 알립니다.</td>
							</tr>
							<tr>
								<td>
									<strong>
										<em>@Deprecated</em>
									</strong>
									<br/> : 앞으로 사용하지 않을 것을 권장하는 대상에게 붙입니다.</td>
							</tr>
							<tr>
								<td>
									<strong>
										<em>@SuppressWarnings</em>
									</strong>
									<br/> : 컴파일러의 특정 경고메세지가 나타나지 않도록 합니다.</td>
							</tr>
							<tr>
								<td>
									<strong>
										<em>@SateVarargs</em>
									</strong>
									<br/> : 지네릭스 타입의 가변인자에 사용합니다. (JDK 1.7)</td>
							</tr>
							<tr>
								<td>
									<strong>
										<em>@FunctionalInterface</em>
									</strong>
									<br/> : 함수형 인터페이스라는 것을 알립니다. (JDK 1.8)</td>
							</tr>
							<tr>
								<td>
									<strong>
										<em>@Native</em>
									</strong>
									<br/> : native 메서드에서 참조되는 상수 앞에 붙입니다. (JDK 1.8)</td>
							</tr>
							<tr>
								<td>
									<strong>
										<em>@Target*</em>
									</strong>
									<br/> : 애너터이션이 적용가능한 대상을 지정하는데 사용합니다.</td>
							</tr>
							<tr>
								<td>
									<strong>
										<em>@Documented*</em>
									</strong>
									<br/> : 애너테이션 정보가 javadoc으로 작성된 문서에 포함되게 합니다.</td>
							</tr>
							<tr>
								<td>
									<strong>
										<em>@Inherited*</em>
									</strong>
									<br/> : 애너테이션이 자손 클래스에 상속되도록 합니다.</td>
							</tr>
							<tr>
								<td>
									<strong>
										<em>@Retention*</em>
									</strong>
									<br/> : 애너테이션이 유지되는 범위를 지정하는데 사용합니다.</td>
							</tr>
							<tr>
								<td>
									<strong>
										<em>@Repeatable*</em>
									</strong>
									<br/> : 애너테이션을 반복해서 적용할 수 있게 합니다. (JDK 1.8)</td>
							</tr>
						</tbody>
					</table>
				</section>

				<hr>

				<section>
					<h2>@Override</h2>
					<p>
						메서드 앞에만 붙일 수 있는 애너테이션으로,
						<strong>조상의 메서드를 오버라이딩하는 것이라는 걸 컴파일러에게 알려주는 역활</strong>을 합니다.
						<br/>오버라이딩할 때 조상 메서드의 이름을 잘못 쓰는 경우(철자, 대소문자) 컴파일러는 이것이 잘못된 것인지 모릅니다. 이럴 경우 메서드 앞에
						<code>@Override</code>라고 애너테이션을 붙이면 컴파일러가 같은 이름의 메서드가 조상에 있는지 확인하고 없으면, 에러메시지를 출력하는 역활을 합니다.
					</p>
				</section>

				<hr>

				<section>
					<h2>@Deprecated</h2>
					<p>
						새로운 버전의 JDK가 소개될 때, 새로운 기능이 추가될 뿐만 아니라 기존의 부족했던 기능들을 개선하기도 합니다. 이 과정에서 기존의 기능을 대체할 것들이 추가되어도, 이미 여러 곳에서 사용되고 있을지 모르는 기존의
						것들을 삭제할 수 없을 것이다. 그래서 더 이상 사용되지 않는 필드나 메서드에
						<code>@Deprecated</code>를 붙이게 됩니다. 이 애너테이션이 붙은 대상은 다른 것으로 대체되었으니 더 이상 사용하지 않을 것을 권장하는 것일 뿐입니다.
						<br/>이 애너테이션이 붙은 대상을 사용하는 코드를 작성하면, 컴파일 할 때 메세지를 출력하게 됩니다.
					</p>
				</section>

				<hr>

				<section>
					<h2>@FunctionalInterface</h2>
					<p>
						함수형 인터페이스(functional interface)를 선언할 때, 이 애너테이션을 붙이면 컴파일러가 함수형 인터페이스를 올바르게 선언했는지 확인하고, 잘못된 경우 에러를 발생시킵니다. 필수는 아니지만 애너테이션을
						붙이면 실수를 방지할 수 있으므로 함수형 인터페이스를 선언할때 반드시 붙이는 습관을 들이도록 합시다.
						<sub>* 함수형 인터페이스는 추상 메서드가 하나뿐이어야 한다는 제약이 있습니다.</sub>
					</p>
				</section>

				<hr>

				<section>
					<h2>@SuppressWarnings</h2>
					<p>
						컴파일러가 보여주는 경고메서지가 나타나지 않게 억제해줍니다. 묵인해야하는 경고가 발생하는 대상에 반드시 붙여서 컴파일 후에 어떤 경고 메세지도 나타나지 않도록 하는 것이 좋습니다.
					</p>
				</section>

				<hr>

				<section>
					<h2>@SafeVarargs</h2>
					<p>
						메서드에 선언된 가변인자의 타입이 non-reifiable타입인 경우, 해당 메서드를 선언하는 부분과 호출하는 부분에서 unchecked경고가 발생합니다. 코드에 문제가 없다면 이 경고를 억제하기 위해 애너테이션을 사용합니다.
						<br/>이 애너테이션은 생성자와 static이나 final이 붙은 메서드에만 붙일 수 있습니다. 즉, 오버라이드될 수 있는 메서드에는 사용할 수 없습니다.
					</p>
				</section>

				<hr>

				<section>
					<h2>@Target</h2>
					<p>
						메타 애너테이션은
						<strong>애너테이션을 위한 애너테이션</strong> 즉, 애너테이셔에 붙이는 애너테이션으로 애너테이션을 정의할 때 애너테이션의 적용대상이나 유지기간등을 지정하는데 사용합니다.
						<code>@Target</code>은 애너테이션이 적용가능한 대상을 지정하는데 사용됩니다. 값을 여러 개 지정할 때는 배열에서처럼 괄호{}를 사용해야 합니다.
					</p>

					<h4>애너테이션 적용대상의 종류</h4>
					<table>
						<thead>
							<tr>
								<th>대상타입</th>
								<th>의미</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>ANNOTATION_TYPE</td>
								<td>애너테이션</td>
							</tr>
							<tr>
								<td>CONSTRUCTOR</td>
								<td>생성자</td>
							</tr>
							<tr>
								<td>FIELD</td>
								<td>필드(멤버변수, enum상수)</td>
							</tr>
							<tr>
								<td>LOCAL_VARIABLE</td>
								<td>지역변수</td>
							</tr>
							<tr>
								<td>METHOD</td>
								<td>메서드</td>
							</tr>
							<tr>
								<td>PACKAGE</td>
								<td>패키지</td>
							</tr>
							<tr>
								<td>PARAMETER</td>
								<td>매개변수</td>
							</tr>
							<tr>
								<td>TYPE</td>
								<td>타입(클래스, 인터페이스, enum)</td>
							</tr>
							<tr>
								<td>TYPE_PARAMETER</td>
								<td>타입 매개변수 (JDK 1.8)</td>
							</tr>
							<tr>
								<td>TYPE_USE</td>
								<td>타입이 사용되는 모든 곳 (JDK 1.8)</td>
							</tr>
						</tbody>
					</table>
				</section>

				<section>
					<h2>@Retention</h2>
					<p>
						애너테이션이 유지(retention)되는 기간을 지정하는데 사용됩니다.
					</p>

					<h4>애너테이션 유지정책의 종류</h4>
					<table>
						<thead>
							<tr>
								<th>유지정책</th>
								<th>의미</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>SOURCE</td>
								<td>소스 파일에만 존재. 클래스 파일에는 존재하지 않음</td>
							</tr>
							<tr>
								<td>CLASS</td>
								<td>클래스 파일에 존재. 실행시에 사용불가 기본값</td>
							</tr>
							<tr>
								<td>RUNTIME</td>
								<td>클래스 파일에 존재. 실행시에 사용가능</td>
							</tr>
						</tbody>
					</table>
				</section>

				<section>
					<h2>@Documented</h2>
					<p>
						애너테이션에 대한 정보가 javadoc으로 작성된 문서에 포함되도록 합니다. 자바에서 제공하는 기본 애너테이션 중에
						<code>@Override</code>와
						<code>@SuppressWarnings</code>를 제외하고는 모두 이 메타 애너테이션이 붙어 있습니다.
					</p>
				</section>

				<hr>

				<section>
					<h2>@Inherited</h2>
					<p>
						애너테이션이 자손 클래스에 상속되도록 합니다.
						<code>@Inherited</code>가 붙은 애너테이션을 조상 클래스에 붙이면, 자손 클래스도 이 애너테이션이 붙은 것과 같이 인식됩니다.
					</p>
				</section>

				<hr>

				<section>
					<h2>@Repeatable</h2>
					<p>
						보통은 하나의 대상에 한 종류의 애너테이션을 붙이는데
						<code>@Repeatable</code>이 붙은 애너테이션은 여러 번 붙일 수 있습니다. 일반적인 애너테이션과 달리 같은 이름의 애너테이션이 여러 개가 하나의 대상에 적용될 수 있기 때문에, 이 애너테이션들을 하나로
						묶어서 다룰 수 있는 애너테이션도 추가로 정의해야 합니다.
					</p>
				</section>

				<hr>

				<section>
					<h2>@Native</h2>
					<p>
						네이티브 메서드는(native method)에 의해 참조되는 상수 필드(constant field)에 붙이는 애너테이션입니다.
						<br/>네이티브 메서드는 JVM이 설치된 OS의 메서드를 말합니다. 네이트비 메서드는 보통 C언어로 작성되어 있는데, 자바에서는 메서드의 선언부만 정의하고 구현은 하지 않으므로 추상 메서드처럼 선언부만 있고 몸통이
						없습니다.
						<br/>이처럼 모든 클래스의 조상인 Object클래스의 메서드들은 대부분 네이티브 메서드입니다.
					</p>
				</section>

				<hr>

				<section>
					<h2>애너테이션 타입 정의하기</h2>
					<p>
						새로운 애너테이션을 정의하는 방법은 아래와 같습니다. 기호(@)를 붙이는 것을 제외하면 인터페이스를 정의하는 것과 동일합니다.
					</p>
					<pre><code>@interface 애너테이션이름 {
	타입요소이름();  // 애너테이션의 요소를 선언
	...
}</code></pre>
					<h2>애너테이션의 요소</h2>
					<p>
						애너테이션 내에 선언된 메서드를 애너테이션의 요소라고 합니다. 애너테이션에도 인터페이스처럼 상수를 정의할 수 있지만, 디폴트 메서드는 정의할 수 없습니다.
						<br/>애너테이션의 각 요소는 기본값을 가질 수 있으며, 기본값이 있는 요소는 애너테이션을 적용할 때 값을 지정하지 않으면 기본값이 사용됩니다. (기본값으로 null을 제외한 모든 리터럴이 가능) 기본값을 지정할
						때도 마찬가지로 괄호{}를 사용할 수 있습니다.
					</p>
					<pre><code>@interface TestInfo {
	int count() default 1;
	String testedBy();
	String[] testTools() default "JUnit";
	TestType testType() default TestType.FIRST;
	DateTime testDate();
}

@interface DateTime {
	String yymmdd();
	String hhmmss();
}</code></pre>

					<p>
						애너테이션의 요소는 반환값이 있고 매개변수는 없는 추상 메서드의 형태를 가지며, 상속을 통해 구현하지 않아도 됩니다. 다만, 애너테이션을 적용할 때 이 요소들의 값을 빠짐없이 지정해주어야 합니다. (요소의 이름을 적어주므로
						순서는 상관없습니다.)
					</p>
					<pre><code>@TestInfo(testedBy="aaa", testDate=@DateTime(yymmdd="160101", hhmmss="235959"))
public class AnnotationEx {
	...
}</code></pre>

					<p>
						애너테이션 요소가 오직 하나뿐이고 이름이 value인 경우, 애너테이션을 적용할 때 요소의 이름을 생략하고 값만 적어도 됩니다. 또한 요소의 타입이 배열일 때도 요소의 이름이 value이면, 요소의 이름을 생략할 수
						있습니다.
					</p>
					<pre><code>@interfage TestInfo {
	String value();
}

@TestInfo("passed")	// @TestInfo(value="passed")와 동일
class NewClass {...}</code></pre>

					<p>
						요소의 타입이 배열인 경우, 괄호{}를 사용해서 여러 개의 값을 지정할 수 있습니다.
					</p>
					<pre><code>@interface TestInfo {
	String[] testTools();
}

@TestInfo(testTools = {"JUnit", "AutoTester"})  // 값이 여러 개인 경우.
@TestInfo(testTools = "JUnit")  // 값이 하나일 경우. 괄호{} 생략
@TestInfo(testTools = {})  // 값이 없는 경우. 괄호{} 생략불가</code></pre>

					<h2>java.lang.annotation.Annotation</h2>
					<p>
						모든 애너테이션의 조상은 Annotation입니다. 하지만 애너테이션은 상속이 허용되지 않으므로 명시적으로 Annotation을 조상으로 지정할 수 없습니다. 게다가 Annotation은 애너테이션이 아니라 일반적인
						인터페이스로 정의되어 있습니다. 때문에 모든 애너테이션 객체에 대해
						<code>equals()</code>,
						<code>hashCode()</code>,
						<code>toString()</code>과 같은 메서드를 호출하는 것이 가능합니다.
					</p>

					<h2>마커 애너테이션(Marker Annotation)</h2>
					<p>
						값을 지정할 필요가 없는 경우, 애너테이션의 요소를 하나도 정의하지 않을 수 있습니다. Serializable이나 Cloneable인터페이스처럼,
						<strong>요소가 하나도 정의되지 않은 애너테이션</strong>을 마커 애너테이션이라고 합니다.
					</p>

					<h2>애너테이션 요소의 규칙</h2>
					<p>
						애너테이션의 요소를 선언할 때 반드시 지켜야 하는 규칙은 다음과 같습니다.
					</p>
					<ul>
						<li>요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용됩니다.</li>
						<li>()안에 매개변수를 선언할 수 없습니다.</li>
						<li>예외를 선언할 수 없습니다.</li>
						<li>요소를 타입 매개변수로 정의할 수 없습니다.</li>
					</ul>

					<ul class="icons source">
						<li>
							<a href="src/AnnotationEx5.html" target="_blank">
								<i class="fas fa-file-code"></i> AnnotationEx.java</a>
						</li>
					</ul>
				</section>

				<hr>

				<ul class="actions fit">
					<li>
						<a href="Enumeration.html" class="button fit">열거형</a>
					</li>
					<li></li>
					<li></li>
				</ul>
			</div>
		</section>
	</div>

	<!-- Footer -->
	<footer id="footer" class="wrapper alt">
		<div class="inner">
			<ul class="menu">
				<li>&copy; KimYong. All rights reserved.</li>
				<li>KINCOWEB:
					<a href="#">KincoWeb Std.</a>
				</li>
			</ul>
		</div>
	</footer>

	<!-- Scripts -->
	<!-- jQuery library -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script src="/website/assets/js/jquery.scrollex.min.js"></script>
	<script src="/website/assets/js/jquery.scrolly.min.js"></script>
	<script src="/website/assets/js/skel.min.js"></script>
	<script src="/website/assets/js/util.js"></script>
	<!--[if lte IE 8]><script src="/website/assets/js/ie/respond.min.js"></script><![endif]-->
	<script src="/website/assets/js/main.js"></script>

</body>

</html>